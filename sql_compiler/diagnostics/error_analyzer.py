import re
from typing import List, Dict, Tuple, Optional, Any
from dataclasses import dataclass
from difflib import get_close_matches
from catalog.catalog_manager import CatalogManager


@dataclass
class ErrorSuggestion:
    """ÈîôËØØÂª∫ËÆÆ"""
    error_type: str
    description: str
    suggestion: str
    corrected_sql: Optional[str] = None
    confidence: float = 0.0  # 0.0 - 1.0


class SQLErrorAnalyzer:
    """SQLÈîôËØØÂàÜÊûêÂô®"""

    def __init__(self, catalog_manager: CatalogManager = None):
        self.catalog_manager = catalog_manager
        self.sql_keywords = {
            'SELECT', 'FROM', 'WHERE', 'GROUP BY', 'HAVING', 'ORDER', 'BY',
            'INSERT', 'INTO', 'VALUES', 'UPDATE', 'SET', 'DELETE', 'CREATE',
            'TABLE', 'DROP', 'ALTER', 'INDEX', 'PRIMARY', 'KEY', 'FOREIGN',
            'REFERENCES', 'NOT', 'NULL', 'UNIQUE', 'DEFAULT', 'AUTO_INCREMENT',
            'INT', 'VARCHAR', 'CHAR', 'TEXT', 'DATE', 'DATETIME', 'TIMESTAMP',
            'DECIMAL', 'FLOAT', 'DOUBLE', 'BOOLEAN', 'TINYINT', 'SMALLINT',
            'MEDIUMINT', 'BIGINT', 'AND', 'OR', 'IN', 'LIKE', 'BETWEEN',
            'IS', 'EXISTS', 'INNER', 'LEFT', 'RIGHT', 'FULL', 'OUTER', 'JOIN',
            'ON', 'UNION', 'DISTINCT', 'AS', 'ASC', 'DESC', 'LIMIT', 'OFFSET',
            'COUNT', 'SUM', 'AVG', 'MAX', 'MIN', 'UPPER', 'LOWER', 'TRIM'
        }

        self.common_functions = {
            'COUNT', 'SUM', 'AVG', 'MAX', 'MIN', 'UPPER', 'LOWER', 'TRIM',
            'SUBSTRING', 'CONCAT', 'LENGTH', 'ROUND', 'ABS', 'NOW', 'CURDATE'
        }

    def analyze_error(self, sql: str, error: Exception) -> List[ErrorSuggestion]:
        """ÂàÜÊûêSQLÈîôËØØÂπ∂Êèê‰æõÂª∫ËÆÆ"""
        suggestions = []
        error_str = str(error).lower()

        # Ê†πÊçÆÈîôËØØÁ±ªÂûãËøõË°åÂàÜÊûê
        if "syntax error" in error_str or "unexpected token" in error_str:
            suggestions.extend(self._analyze_syntax_errors(sql, error))

        if "table" in error_str and ("not found" in error_str or "doesn't exist" in error_str):
            suggestions.extend(self._analyze_table_errors(sql, error))

        if "column" in error_str and ("not found" in error_str or "unknown" in error_str):
            suggestions.extend(self._analyze_column_errors(sql, error))

        if "function" in error_str and ("not found" in error_str or "unknown" in error_str):
            suggestions.extend(self._analyze_function_errors(sql, error))

        # ÈÄöÁî®ÂàÜÊûê
        suggestions.extend(self._analyze_common_mistakes(sql))

        # ÊåâÁΩÆ‰ø°Â∫¶ÊéíÂ∫è
        suggestions.sort(key=lambda x: x.confidence, reverse=True)
        return suggestions[:5]

    def suggest_corrections(self, sql: str) -> List[ErrorSuggestion]:
        """‰∏∫SQLÊèê‰æõÊîπËøõÂª∫ËÆÆÔºàÂç≥‰ΩøÊ≤°ÊúâÈîôËØØÔºâ- ‰øÆÂ§çÁâàÊú¨"""
        suggestions = []
        sql_upper = sql.upper()

        # üîë Êñ∞Â¢ûÔºö‰∏ªÂä®ËøõË°åËØ≠Ê≥ïÊ£ÄÊü•
        suggestions.extend(self._proactive_syntax_check(sql))

        # 1. ÊÄßËÉΩÂª∫ËÆÆ
        if 'SELECT *' in sql_upper and 'WHERE' not in sql_upper:
            suggestions.append(ErrorSuggestion(
                error_type="PERFORMANCE_TIP",
                description="ÊÄßËÉΩÊèêÁ§∫",
                suggestion="ËÄÉËôëÂè™ÈÄâÊã©ÈúÄË¶ÅÁöÑÂàóÔºåÂπ∂Ê∑ªÂä†WHEREÊù°‰ª∂Êù•ÈôêÂà∂ÁªìÊûúÈõÜ",
                confidence=0.4
            ))

        # 2. ÂÆâÂÖ®Âª∫ËÆÆ
        if any(dangerous in sql_upper for dangerous in ['DROP', 'DELETE FROM', 'TRUNCATE']):
            suggestions.append(ErrorSuggestion(
                error_type="SAFETY_WARNING",
                description="ÂÆâÂÖ®Ë≠¶Âëä",
                suggestion="Ëøô‰∏™Êìç‰Ωú‰ºö‰øÆÊîπÊàñÂà†Èô§Êï∞ÊçÆÔºåËØ∑Á°ÆËÆ§Êìç‰ΩúÁöÑÊ≠£Á°ÆÊÄß",
                confidence=0.8
            ))

        return suggestions

    def _proactive_syntax_check(self, sql: str) -> List[ErrorSuggestion]:
        """‰∏ªÂä®ËøõË°åËØ≠Ê≥ïÊ£ÄÊü•Ôºà‰∏çÈúÄË¶ÅÈîôËØØÂç≥ÂèØÊ£ÄÊü•Ôºâ"""
        suggestions = []
        sql_upper = sql.upper()

        # 1. Áº∫Â∞ëÂàÜÂè∑Ê£ÄÊü•
        if not sql.strip().endswith(';'):
            suggestions.append(ErrorSuggestion(
                error_type="MISSING_SEMICOLON",
                description="SQLËØ≠Âè•Áº∫Â∞ëÁªìÂ∞æÂàÜÂè∑",
                suggestion="Âú®SQLËØ≠Âè•Êú´Â∞æÊ∑ªÂä†ÂàÜÂè∑ (;)",
                corrected_sql=sql.strip() + ';',
                confidence=0.9
            ))

        # 2. Êã¨Âè∑‰∏çÂåπÈÖçÊ£ÄÊü•
        open_parens = sql.count('(')
        close_parens = sql.count(')')
        if open_parens != close_parens:
            suggestions.append(ErrorSuggestion(
                error_type="UNMATCHED_PARENTHESES",
                description=f"Êã¨Âè∑‰∏çÂåπÈÖçÔºöÂºÄÊã¨Âè∑{open_parens}‰∏™ÔºåÈó≠Êã¨Âè∑{close_parens}‰∏™",
                suggestion="Ê£ÄÊü•Âπ∂‰øÆÊ≠£Êã¨Âè∑ÂåπÈÖç",
                confidence=0.8
            ))

        # 3. Â∏∏ËßÅÂÖ≥ÈîÆÂ≠óÊãºÂÜôÈîôËØØÊ£ÄÊü• - Âè™Âú®ÂÖ≥ÈîÆÂ≠ó‰ΩçÁΩÆÊ£ÄÊü•
        # ÊèêÂèñSQL‰∏≠ÁöÑÂÖ≥ÈîÆÂ≠ó‰ΩçÁΩÆ
        keyword_positions = self._find_keyword_positions(sql_upper)

        for position, word in keyword_positions:
            if word not in self.sql_keywords and len(word) > 2:
                matches = get_close_matches(word, self.sql_keywords, n=3, cutoff=0.6)
                if matches:
                    # Âè™ÊõøÊç¢ÂÖ≥ÈîÆÂ≠ó‰ΩçÁΩÆÁöÑÂçïËØçÔºåËÄå‰∏çÊòØÊâÄÊúâÂá∫Áé∞ÁöÑÂú∞Êñπ
                    sql_list = list(sql_upper)
                    sql_list[position:position + len(word)] = list(matches[0])
                    corrected_sql = ''.join(sql_list).lower()

                    suggestions.append(ErrorSuggestion(
                        error_type="KEYWORD_TYPO",
                        description=f"ÂèØËÉΩÁöÑÂÖ≥ÈîÆÂ≠óÊãºÂÜôÈîôËØØÔºö'{word}'",
                        suggestion=f"‰Ω†ÊòØÂê¶ÊÉ≥ÂÜô '{matches[0]}'ÔºüÂÖ∂‰ªñÂèØËÉΩÔºö{', '.join(matches[1:])}",
                        corrected_sql=corrected_sql,
                        confidence=0.7
                    ))

        # 4. SELECTÂêéÁº∫Â∞ëÂàóÂêçÊ£ÄÊü•
        if re.search(r'SELECT\s+FROM', sql_upper):
            suggestions.append(ErrorSuggestion(
                error_type="MISSING_COLUMNS",
                description="SELECTÂíåFROM‰πãÈó¥Áº∫Â∞ëÂàóÂêç",
                suggestion="Âú®SELECTÂíåFROM‰πãÈó¥ÊåáÂÆöË¶ÅÊü•ËØ¢ÁöÑÂàóÔºåÊàñ‰ΩøÁî® * Êü•ËØ¢ÊâÄÊúâÂàó",
                corrected_sql=sql.upper().replace('SELECT FROM', 'SELECT * FROM').lower(),
                confidence=0.8
            ))

        # 5. Â≠óÁ¨¶‰∏≤ÂÄºÂèØËÉΩÁº∫Â∞ëÂºïÂè∑
        equals_pattern = r'=\s*([a-zA-Z]\w*)\b'
        matches = re.findall(equals_pattern, sql)
        if matches:
            suggestions.append(ErrorSuggestion(
                error_type="MISSING_QUOTES",
                description="Â≠óÁ¨¶‰∏≤ÂÄºÂèØËÉΩÁº∫Â∞ëÂºïÂè∑",
                suggestion="Â≠óÁ¨¶‰∏≤ÂÄºÂ∫îËØ•Áî®ÂçïÂºïÂè∑ÊàñÂèåÂºïÂè∑ÂåÖÂõ¥Ôºå‰æãÂ¶ÇÔºöname = 'John'",
                confidence=0.5
            ))

        # 6. JOINÁº∫Â∞ëONÂ≠êÂè•Ê£ÄÊü•
        if 'JOIN' in sql_upper and 'ON' not in sql_upper:
            suggestions.append(ErrorSuggestion(
                error_type="MISSING_JOIN_CONDITION",
                description="JOINËØ≠Âè•Áº∫Â∞ëONÊù°‰ª∂",
                suggestion="JOINËØ≠Âè•ÈúÄË¶ÅÊåáÂÆöËøûÊé•Êù°‰ª∂Ôºå‰æãÂ¶ÇÔºöLEFT JOIN table2 ON table1.id = table2.id",
                confidence=0.7
            ))

        return suggestions

    def _find_keyword_positions(self, sql_upper: str) -> List[Tuple[int, str]]:
        """ÊâæÂà∞SQL‰∏≠ÂèØËÉΩÁöÑÂÖ≥ÈîÆÂ≠ó‰ΩçÁΩÆ"""
        keyword_positions = []

        # Êü•ÊâæSQLÂÖ≥ÈîÆÂ≠óÁöÑ‰ΩçÁΩÆÔºàÂú®ÁâπÂÆö‰∏ä‰∏ãÊñá‰∏≠Ôºâ
        patterns = [
            (
            r'\b(SELECT|FROM|WHERE|GROUP BY|HAVING|ORDER BY|INSERT INTO|VALUES|UPDATE|SET|DELETE FROM|CREATE TABLE|DROP TABLE|ALTER TABLE|JOIN|LEFT JOIN|RIGHT JOIN|INNER JOIN|OUTER JOIN)\b',
            1),
            (r'\b(AND|OR|NOT|IN|LIKE|BETWEEN|IS NULL|IS NOT NULL|EXISTS)\b', 1),
            (r'\b(INT|VARCHAR|CHAR|TEXT|DATE|DATETIME|TIMESTAMP|DECIMAL|FLOAT|DOUBLE|BOOLEAN)\b', 1),
            (r'\b(PRIMARY KEY|FOREIGN KEY|REFERENCES|UNIQUE|NOT NULL|DEFAULT|AUTO_INCREMENT)\b', 2)
        ]

        for pattern, group in patterns:
            for match in re.finditer(pattern, sql_upper):
                keyword = match.group(group) if group <= len(match.groups()) else match.group(0)
                keyword_positions.append((match.start(), keyword))

        return keyword_positions

    def _analyze_syntax_errors(self, sql: str, error: Exception) -> List[ErrorSuggestion]:
        """ÂàÜÊûêËØ≠Ê≥ïÈîôËØØ"""
        suggestions = []
        sql_upper = sql.upper()

        # 1. Áº∫Â∞ëÂàÜÂè∑
        if not sql.strip().endswith(';'):
            suggestions.append(ErrorSuggestion(
                error_type="MISSING_SEMICOLON",
                description="SQLËØ≠Âè•Áº∫Â∞ëÁªìÂ∞æÂàÜÂè∑",
                suggestion="Âú®SQLËØ≠Âè•Êú´Â∞æÊ∑ªÂä†ÂàÜÂè∑ (;)",
                corrected_sql=sql.strip() + ';',
                confidence=0.9
            ))

        # 2. Êã¨Âè∑‰∏çÂåπÈÖç
        open_parens = sql.count('(')
        close_parens = sql.count(')')
        if open_parens != close_parens:
            suggestions.append(ErrorSuggestion(
                error_type="UNMATCHED_PARENTHESES",
                description=f"Êã¨Âè∑‰∏çÂåπÈÖçÔºöÂºÄÊã¨Âè∑{open_parens}‰∏™ÔºåÈó≠Êã¨Âè∑{close_parens}‰∏™",
                suggestion="Ê£ÄÊü•Âπ∂‰øÆÊ≠£Êã¨Âè∑ÂåπÈÖç",
                confidence=0.8
            ))

        # 3. Â∏∏ËßÅÂÖ≥ÈîÆÂ≠óÊãºÂÜôÈîôËØØ - Âè™Âú®ÂÖ≥ÈîÆÂ≠ó‰ΩçÁΩÆÊ£ÄÊü•
        keyword_positions = self._find_keyword_positions(sql_upper)

        for position, word in keyword_positions:
            if word not in self.sql_keywords and len(word) > 2:
                matches = get_close_matches(word, self.sql_keywords, n=3, cutoff=0.6)
                if matches:
                    sql_list = list(sql_upper)
                    sql_list[position:position + len(word)] = list(matches[0])
                    corrected_sql = ''.join(sql_list).lower()

                    suggestions.append(ErrorSuggestion(
                        error_type="KEYWORD_TYPO",
                        description=f"ÂèØËÉΩÁöÑÂÖ≥ÈîÆÂ≠óÊãºÂÜôÈîôËØØÔºö'{word}'",
                        suggestion=f"‰Ω†ÊòØÂê¶ÊÉ≥ÂÜô '{matches[0]}'ÔºüÂÖ∂‰ªñÂèØËÉΩÔºö{', '.join(matches[1:])}",
                        corrected_sql=corrected_sql,
                        confidence=0.7
                    ))

        # 4. SELECTÂêéÁº∫Â∞ëÂàóÂêç
        if re.search(r'SELECT\s+FROM', sql_upper):
            suggestions.append(ErrorSuggestion(
                error_type="MISSING_COLUMNS",
                description="SELECTÂíåFROM‰πãÈó¥Áº∫Â∞ëÂàóÂêç",
                suggestion="Âú®SELECTÂíåFROM‰πãÈó¥ÊåáÂÆöË¶ÅÊü•ËØ¢ÁöÑÂàóÔºåÊàñ‰ΩøÁî® * Êü•ËØ¢ÊâÄÊúâÂàó",
                corrected_sql=sql.upper().replace('SELECT FROM', 'SELECT * FROM').lower(),
                confidence=0.8
            ))

        # 5. GROUP BYÂêéÁº∫Â∞ëHAVINGÁöÑÈîôËØØ‰ΩøÁî®
        if 'GROUP BY' in sql_upper and 'WHERE' in sql_upper:
            # Ê£ÄÊü•ÊòØÂê¶Âú®WHERE‰∏≠‰ΩøÁî®‰∫ÜËÅöÂêàÂáΩÊï∞
            where_part = sql_upper.split('GROUP BY')[0].split('WHERE')[1] if 'WHERE' in sql_upper.split('GROUP BY')[
                0] else ""
            if any(func in where_part for func in ['COUNT(', 'SUM(', 'AVG(', 'MAX(', 'MIN(']):
                suggestions.append(ErrorSuggestion(
                    error_type="AGGREGATE_IN_WHERE",
                    description="WHEREÂ≠êÂè•‰∏≠‰∏çËÉΩ‰ΩøÁî®ËÅöÂêàÂáΩÊï∞",
                    suggestion="ËÅöÂêàÂáΩÊï∞ÁöÑÊù°‰ª∂Â∫îËØ•ÊîæÂú®HAVINGÂ≠êÂè•‰∏≠",
                    confidence=0.7
                ))

        return suggestions

    def _analyze_table_errors(self, sql: str, error: Exception) -> List[ErrorSuggestion]:
        """ÂàÜÊûêË°®Áõ∏ÂÖ≥ÈîôËØØ"""
        suggestions = []

        if not self.catalog_manager:
            return suggestions

        # ÊèêÂèñSQL‰∏≠ÁöÑË°®Âêç
        table_pattern = r'FROM\s+(\w+)|JOIN\s+(\w+)|INTO\s+(\w+)|UPDATE\s+(\w+)'
        matches = re.findall(table_pattern, sql, re.IGNORECASE)

        mentioned_tables = []
        for match_group in matches:
            for table in match_group:
                if table:
                    mentioned_tables.append(table.lower())

        # Ëé∑ÂèñÊï∞ÊçÆÂ∫ì‰∏≠ÂÆûÈôÖÂ≠òÂú®ÁöÑË°®
        try:
            existing_tables = [t.lower() for t in self.catalog_manager.get_all_tables()]
        except:
            existing_tables = []

        for table in mentioned_tables:
            if table not in existing_tables:
                # Êü•ÊâæÁõ∏‰ººÁöÑË°®Âêç
                similar_tables = get_close_matches(table, existing_tables, n=3, cutoff=0.6)

                if similar_tables:
                    corrected_sql = sql.lower().replace(table, similar_tables[0])
                    suggestions.append(ErrorSuggestion(
                        error_type="TABLE_NOT_FOUND",
                        description=f"Ë°® '{table}' ‰∏çÂ≠òÂú®",
                        suggestion=f"‰Ω†ÊòØÂê¶ÊÉ≥Ë¶ÅÊü•ËØ¢Ë°® '{similar_tables[0]}'ÔºüÂÖ∂‰ªñÂèØËÉΩÔºö{', '.join(similar_tables[1:])}",
                        corrected_sql=corrected_sql,
                        confidence=0.8
                    ))
                else:
                    # ÊòæÁ§∫Â≠òÂú®ÁöÑË°®
                    if existing_tables:
                        suggestions.append(ErrorSuggestion(
                            error_type="TABLE_NOT_FOUND",
                            description=f"Ë°® '{table}' ‰∏çÂ≠òÂú®",
                            suggestion=f"ÂΩìÂâçÊï∞ÊçÆÂ∫ì‰∏≠ÁöÑË°®ÊúâÔºö{', '.join(existing_tables)}",
                            confidence=0.6
                        ))
                    else:
                        suggestions.append(ErrorSuggestion(
                            error_type="NO_TABLES",
                            description="Êï∞ÊçÆÂ∫ì‰∏≠Ê≤°Êúâ‰ªª‰ΩïË°®",
                            suggestion="ËØ∑ÂÖàÂàõÂª∫Ë°®Ôºå‰æãÂ¶ÇÔºöCREATE TABLE table_name (id INT, name VARCHAR(50));",
                            confidence=0.7
                        ))

        return suggestions

    def _analyze_column_errors(self, sql: str, error: Exception) -> List[ErrorSuggestion]:
        """ÂàÜÊûêÂàóÁõ∏ÂÖ≥ÈîôËØØ"""
        suggestions = []

        if not self.catalog_manager:
            return suggestions

        # ÁÆÄÂåñÁöÑÂàóÂêçÊèêÂèñÔºàÂÆûÈôÖÈ°πÁõÆ‰∏≠ÈúÄË¶ÅÊõ¥Â§çÊùÇÁöÑËß£ÊûêÔºâ
        # ÊèêÂèñSELECTÂêéÁöÑÂàóÂêç
        select_match = re.search(r'SELECT\s+(.*?)\s+FROM', sql, re.IGNORECASE | re.DOTALL)
        if select_match:
            columns_str = select_match.group(1)
            # ÁÆÄÂçïÂàÜÂâ≤ÂàóÂêçÔºàÂøΩÁï•Â§çÊùÇÁöÑË°®ËææÂºèÔºâ
            mentioned_columns = []
            for col in columns_str.split(','):
                col = col.strip()
                if col != '*' and not any(func in col.upper() for func in self.common_functions):
                    # ÊèêÂèñÁ∫ØÂàóÂêçÔºàÂéªÈô§Âà´ÂêçÁ≠âÔºâ
                    col_name = col.split()[0] if col else ""
                    if col_name and col_name.isalpha():
                        mentioned_columns.append(col_name.lower())

        # ÊèêÂèñË°®Âêç
        table_match = re.search(r'FROM\s+(\w+)', sql, re.IGNORECASE)
        if table_match:
            table_name = table_match.group(1).lower()

            try:
                # Ëé∑ÂèñË°®ÁöÑÂàó‰ø°ÊÅØ
                table_columns = []
                schema = self.catalog_manager.get_table_schema(table_name)
                if schema:
                    table_columns = [col[0].lower() for col in schema]

                for mentioned_col in mentioned_columns:
                    if mentioned_col not in table_columns:
                        # Êü•ÊâæÁõ∏‰ººÁöÑÂàóÂêç
                        similar_columns = get_close_matches(mentioned_col, table_columns, n=3, cutoff=0.6)

                        if similar_columns:
                            corrected_sql = sql.lower().replace(mentioned_col, similar_columns[0])
                            suggestions.append(ErrorSuggestion(
                                error_type="COLUMN_NOT_FOUND",
                                description=f"Ë°® '{table_name}' ‰∏≠‰∏çÂ≠òÂú®Âàó '{mentioned_col}'",
                                suggestion=f"‰Ω†ÊòØÂê¶ÊÉ≥Ë¶ÅÊü•ËØ¢Âàó '{similar_columns[0]}'ÔºüÂÖ∂‰ªñÂèØËÉΩÔºö{', '.join(similar_columns[1:])}",
                                corrected_sql=corrected_sql,
                                confidence=0.8
                            ))
                        else:
                            suggestions.append(ErrorSuggestion(
                                error_type="COLUMN_NOT_FOUND",
                                description=f"Ë°® '{table_name}' ‰∏≠‰∏çÂ≠òÂú®Âàó '{mentioned_col}'",
                                suggestion=f"Ë°® '{table_name}' ‰∏≠ÁöÑÂàóÊúâÔºö{', '.join(table_columns)}",
                                confidence=0.6
                            ))
            except Exception:
                pass

        return suggestions

    def _analyze_function_errors(self, sql: str, error: Exception) -> List[ErrorSuggestion]:
        """ÂàÜÊûêÂáΩÊï∞Áõ∏ÂÖ≥ÈîôËØØ"""
        suggestions = []

        # ÊèêÂèñÂèØËÉΩÁöÑÂáΩÊï∞Âêç
        function_pattern = r'(\w+)\s*\('
        functions = re.findall(function_pattern, sql, re.IGNORECASE)

        for func in functions:
            func_upper = func.upper()
            if func_upper not in self.common_functions and func_upper not in self.sql_keywords:
                # Êü•ÊâæÁõ∏‰ººÁöÑÂáΩÊï∞Âêç
                similar_functions = get_close_matches(func_upper, self.common_functions, n=3, cutoff=0.6)

                if similar_functions:
                    corrected_sql = sql.replace(func, similar_functions[0].lower())
                    suggestions.append(ErrorSuggestion(
                        error_type="FUNCTION_NOT_FOUND",
                        description=f"Êú™Áü•ÂáΩÊï∞ '{func}'",
                        suggestion=f"‰Ω†ÊòØÂê¶ÊÉ≥‰ΩøÁî® '{similar_functions[0]}'ÔºüÂÖ∂‰ªñÂèØËÉΩÔºö{', '.join(similar_functions[1:])}",
                        corrected_sql=corrected_sql,
                        confidence=0.7
                    ))

        return suggestions

    def _analyze_common_mistakes(self, sql: str) -> List[ErrorSuggestion]:
        """ÂàÜÊûêÂ∏∏ËßÅÈîôËØØ"""
        suggestions = []
        sql_upper = sql.upper()

        # 1. Â≠óÁ¨¶‰∏≤ÂÄºÊ≤°ÊúâÂºïÂè∑
        # ÁÆÄÂåñÊ£ÄÊµãÔºöÊü•Êâæ = ÂêéÈù¢ÁöÑÈùûÊï∞Â≠óÂÄº
        equals_pattern = r'=\s*([a-zA-Z]\w*)\b'
        matches = re.findall(equals_pattern, sql)
        if matches:
            suggestions.append(ErrorSuggestion(
                error_type="MISSING_QUOTES",
                description="Â≠óÁ¨¶‰∏≤ÂÄºÂèØËÉΩÁº∫Â∞ëÂºïÂè∑",
                suggestion="Â≠óÁ¨¶‰∏≤ÂÄºÂ∫îËØ•Áî®ÂçïÂºïÂè∑ÊàñÂèåÂºïÂè∑ÂåÖÂõ¥Ôºå‰æãÂ¶ÇÔºöname = 'John'",
                confidence=0.5
            ))

        # 2. LIMITÂ≠êÂè•ËØ≠Ê≥ïÈîôËØØ
        if 'LIMIT' in sql_upper and 'OFFSET' not in sql_upper:
            limit_pattern = r'LIMIT\s+(\d+)\s*,\s*(\d+)'
            if re.search(limit_pattern, sql, re.IGNORECASE):
                suggestions.append(ErrorSuggestion(
                    error_type="LIMIT_SYNTAX",
                    description="LIMITÂ≠êÂè•ËØ≠Ê≥ïÂèØËÉΩ‰∏çÊ≠£Á°Æ",
                    suggestion="Ê†áÂáÜËØ≠Ê≥ïÊòØ LIMIT count Êàñ LIMIT offset, count",
                    confidence=0.6
                ))

        # 3. JOINÁº∫Â∞ëONÂ≠êÂè•
        if 'JOIN' in sql_upper and 'ON' not in sql_upper:
            suggestions.append(ErrorSuggestion(
                error_type="MISSING_JOIN_CONDITION",
                description="JOINËØ≠Âè•Áº∫Â∞ëONÊù°‰ª∂",
                suggestion="JOINËØ≠Âè•ÈúÄË¶ÅÊåáÂÆöËøûÊé•Êù°‰ª∂Ôºå‰æãÂ¶ÇÔºöLEFT JOIN table2 ON table1.id = table2.id",
                confidence=0.7
            ))

        # 4. ËÅöÂêàÂáΩÊï∞‰∏éÈùûËÅöÂêàÂàóÊ∑∑Áî®
        if 'GROUP BY' not in sql_upper:
            has_aggregate = any(func in sql_upper for func in ['COUNT(', 'SUM(', 'AVG(', 'MAX(', 'MIN('])
            select_match = re.search(r'SELECT\s+(.*?)\s+FROM', sql, re.IGNORECASE | re.DOTALL)
            if has_aggregate and select_match:
                columns_str = select_match.group(1)
                # ÁÆÄÂåñÊ£ÄÊµãÔºöÂ¶ÇÊûúÊúâËÅöÂêàÂáΩÊï∞Ôºå‰ΩÜ‰πüÊúâÂÖ∂‰ªñÈùûËÅöÂêàÂàó
                if ',' in columns_str and any(
                        func not in columns_str.upper() for func in ['COUNT(', 'SUM(', 'AVG(', 'MAX(', 'MIN(']):
                    suggestions.append(ErrorSuggestion(
                        error_type="AGGREGATE_WITHOUT_GROUP_BY",
                        description="‰ΩøÁî®ËÅöÂêàÂáΩÊï∞Êó∂ÂèØËÉΩÈúÄË¶ÅGROUP BY",
                        suggestion="ÂΩìSELECT‰∏≠ÊúâËÅöÂêàÂáΩÊï∞Êó∂ÔºåÊâÄÊúâÈùûËÅöÂêàÂàóÈÉΩÈúÄË¶ÅÂú®GROUP BY‰∏≠",
                        confidence=0.6
                    ))

        return suggestions


class SmartSQLCorrector:
    """Êô∫ËÉΩSQLÁ∫†ÈîôÂô®"""

    def __init__(self, catalog_manager: CatalogManager = None):
        self.analyzer = SQLErrorAnalyzer(catalog_manager)
        self.correction_history = []

    def analyze_and_suggest(self, sql: str, error: Exception = None) -> Dict[str, Any]:
        """ÂàÜÊûêSQLÂπ∂Êèê‰æõÂª∫ËÆÆ - ‰øÆÂ§çÁâàÊú¨"""
        result = {
            'original_sql': sql,
            'has_error': error is not None,
            'error_message': str(error) if error else None,
            'suggestions': [],
            'corrected_sql_options': [],
            'improvement_tips': []
        }

        if error:
            # ÊúâÈîôËØØÊó∂ËøõË°åÈîôËØØÂàÜÊûê
            suggestions = self.analyzer.analyze_error(sql, error)
            result['suggestions'] = [self._format_suggestion(s) for s in suggestions]

            # Êèê‰æõÂèØËÉΩÁöÑ‰øÆÊ≠£ÁâàÊú¨
            corrected_options = [s for s in suggestions if s.corrected_sql]
            result['corrected_sql_options'] = [
                {
                    'sql': s.corrected_sql,
                    'description': s.suggestion,
                    'confidence': s.confidence
                }
                for s in corrected_options[:3]  # ÊúÄÂ§ö3‰∏™ÈÄâÈ°π
            ]
        else:
            # üîë ‰øÆÂ§çÔºöÊ≤°ÊúâÈîôËØØÊó∂‰πüËøõË°åÂÆåÊï¥ÁöÑÊ£ÄÊü•
            improvements = self.analyzer.suggest_corrections(sql)

            # üîë Â∞ÜËØ≠Ê≥ïÈóÆÈ¢ò‰πüÂΩíÁ±ª‰∏∫ÊîπËøõÂª∫ËÆÆ
            syntax_issues = [s for s in improvements if s.error_type in [
                'MISSING_SEMICOLON', 'UNMATCHED_PARENTHESES', 'KEYWORD_TYPO',
                'MISSING_COLUMNS', 'MISSING_QUOTES', 'MISSING_JOIN_CONDITION'
            ]]

            other_improvements = [s for s in improvements if s.error_type not in [
                'MISSING_SEMICOLON', 'UNMATCHED_PARENTHESES', 'KEYWORD_TYPO',
                'MISSING_COLUMNS', 'MISSING_QUOTES', 'MISSING_JOIN_CONDITION'
            ]]

            # Â¶ÇÊûúÊúâËØ≠Ê≥ïÈóÆÈ¢òÔºåÊîæÂà∞suggestions‰∏≠
            if syntax_issues:
                result['suggestions'] = [self._format_suggestion(s) for s in syntax_issues]

                # Êèê‰æõ‰øÆÊ≠£ÈÄâÈ°π
                corrected_options = [s for s in syntax_issues if s.corrected_sql]
                result['corrected_sql_options'] = [
                    {
                        'sql': s.corrected_sql,
                        'description': s.suggestion,
                        'confidence': s.confidence
                    }
                    for s in corrected_options[:3]
                ]

            # ÂÖ∂‰ªñÊîπËøõÂª∫ËÆÆ
            result['improvement_tips'] = [self._format_suggestion(s) for s in other_improvements]

        return result

    def _format_suggestion(self, suggestion: ErrorSuggestion) -> Dict[str, Any]:
        """Ê†ºÂºèÂåñÂª∫ËÆÆ"""
        return {
            'type': suggestion.error_type,
            'description': suggestion.description,
            'suggestion': suggestion.suggestion,
            'confidence': suggestion.confidence,
            'corrected_sql': suggestion.corrected_sql
        }